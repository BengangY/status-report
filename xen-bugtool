#!/usr/bin/env python

# This library is free software; you can redistribute it and/or
# modify it under the terms of version 2.1 of the GNU Lesser General Public
# License as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Copyright (c) 2005, 2007 XenSource Ltd.


#
# To add new entries to the bugtool, you need to:
#
# Create a new capability.  These declare the new entry to the GUI, including
# the expected size, time to collect, privacy implications, and whether the
# capability should be selected by default.  One capability may refer to
# multiple files, assuming that they can be reasonably grouped together, and
# have the same privacy implications.  You need:
#
#   A new CAP_ constant.
#   A cap() invocation to declare the capability.
#
# You then need to add calls to main() to collect the files.  These will
# typically be calls to the helpers send(), send_all(), cmd(), or do().
#

import errno
import getopt
import getpass
import httplib
import re
import os
import os.path
import string
import StringIO
import sys
import tarfile
import time
import urllib
import commands
import shutil
import pprint
from xml.dom.minidom import parse, getDOMImplementation
import zipfile
from subprocess import Popen, PIPE
from select import select
from signal import SIGTERM, SIGUSR1
import md5
import platform

sys.path.append('/usr/lib/python')
sys.path.append('/usr/lib64/python')

import sexp
import xen.lowlevel.xc

OS_RELEASE = platform.release()

#
# Files & directories
#

TMP_DIR = '/tmp/bugtool.%d' % os.getpid()
BUG_DIR = "/var/opt/xen/bug-report"
GRUB_CONFIG = '/boot/grub/menu.lst'
BOOT_KERNEL = '/boot/vmlinuz-' + OS_RELEASE
BOOT_INITRD = '/boot/initrd-' + OS_RELEASE + '.img'
PROC_PARTITIONS = '/proc/partitions'
FSTAB = '/etc/fstab'
PROC_MOUNTS = '/proc/mounts'
ISCSI_CONF = '/etc/iscsi/iscsid.conf'
ISCSI_INITIATOR = '/etc/iscsi/initiatorname.iscsi'
LVM_CACHE = '/etc/lvm/.cache'
PROC_CPUINFO = '/proc/cpuinfo'
PROC_MEMINFO = '/proc/meminfo'
PROC_IOPORTS = '/proc/ioports'
PROC_INTERRUPTS = '/proc/interrupts'
PROC_SCSI = '/proc/scsi/scsi'
FIRSTBOOT_DIR = '/etc/firstboot.d'
PROC_VERSION = '/proc/version'
PROC_MODULES = '/proc/modules'
PROC_DEVICES = '/proc/devices'
PROC_FILESYSTEMS = '/proc/filesystems'
PROC_CMDLINE = '/proc/cmdline'
PROC_CONFIG = '/proc/config.gz'
SYSCONFIG_NETWORK = '/etc/sysconfig/network'
SYSCONFIG_NETWORK_SCRIPTS = '/etc/sysconfig/network-scripts'
IFCFG_RE = re.compile(r'^.*/ifcfg-.*')
RESOLV_CONF = '/etc/resolv.conf'
NSSWITCH_CONF = '/etc/nsswitch.conf'
NTP_CONF = '/etc/ntp.conf'
IPTABLES_CONFIG = '/etc/sysconfig/iptables-config'
HOSTS_ALLOW = '/etc/hosts.allow'
HOSTS_DENY = '/etc/hosts.deny'
DHCP_LEASE_DIR = '/var/lib/dhclient'
VAR_LOG_DIR = '/var/log/'
XENSOURCE_INVENTORY = '/etc/xensource-inventory'
VENDORKERNEL_INVENTORY = '/etc/vendorkernel-inventory'
XAPI_LOCAL_DB = '/var/xapi/local.db'
POOL_CONF = '/etc/xensource/pool.conf'
XAPI_CONF = '/etc/xensource/xapi.conf'
XAPI_SSL_CONF = '/etc/xensource/xapi-ssl.conf'
HOST_CRASHDUMPS_DIR = '/var/crash'
HOST_CRASHDUMP_LOGS_RE = re.compile(r'^.*\.log$')
X11_LOGS_DIR = VAR_LOG_DIR
X11_LOGS_RE = re.compile(r'.*/Xorg\..*$')
XENSERVER_LOGS = \
    [ VAR_LOG_DIR + x for x in
      ['xensource.log', 'SMlog'] +
      ['xensource.log.%d' % y for y in range(1,21)] +
      ['SMlog.%d' % y for y in range(1,20)] +
      ['xen/xenstored-trace.log',
       'xen/xen-hotplug.log',
       'xen/domain-builder-ng.log'] +
      [ 'xen/xenstored-access.log.%d' % y for y in range(1,20)]]
YUM_LOG = '/var/log/yum.log'
YUM_REPOS_DIR = '/etc/yum.repos.d'


BOOT_MD5SUMS = TMP_DIR + '/boot.ms5sum'
BOOT_LISTING = TMP_DIR + '/boot.list'
PARTITIONS_OUT = TMP_DIR + '/proc/partitions.out'
MOUNTS_OUT = TMP_DIR + '/proc/mounts.out'
FDISK_OUT = TMP_DIR + '/fdisk-l.out'
DF_OUT = TMP_DIR + '/df-alT.out'
DFI_OUT = TMP_DIR + '/df-alTi.out'
ISCSI_NODE_OUT = TMP_DIR + '/iscsiadm-m-node.out'
PVS_OUT = TMP_DIR + '/pvs.out'
VGS_OUT = TMP_DIR + '/vgs.out'
LVS_OUT = TMP_DIR + '/lvs.out'
DMI_OUT = TMP_DIR + '/dmidecode.out'
CPUINFO_OUT = TMP_DIR + '/proc/cpuinfo.out'
MEMINFO_OUT = TMP_DIR + '/proc/meminfo.out'
IOPORTS_OUT = TMP_DIR + '/proc/ioports.out'
INTERRUPTS_OUT = TMP_DIR + '/proc/interrupts.out'
HDPARM_I_OUT = TMP_DIR + '/hdparm-I-%s.out'
HDPARM_TT_OUT = TMP_DIR + '/hdparm-tT-%s.out'
LSPCI_N_OUT = TMP_DIR + '/lspci-n.out'
LSPCI_VV_OUT = TMP_DIR + '/lspci-vv.out'
LSUSB_OUT = TMP_DIR + '/lsusb.out'
SCSI_OUT = TMP_DIR + '/proc/scsi.out'
VERSION_OUT = TMP_DIR + '/proc/version.out'
MODULES_OUT = TMP_DIR + '/proc/modules.out'
DEVICES_OUT = TMP_DIR + '/proc/devices.out'
FILESYSTEMS_OUT = TMP_DIR + '/proc/filesystems.out'
CMDLINE_OUT = TMP_DIR + '/proc/cmdline.out'
CONFIG_OUT = TMP_DIR + '/proc/config.out'
SYSCTL_OUT = TMP_DIR + '/sysctl-A.out'
IFCONFIG_OUT = TMP_DIR + '/ifconfig-a.out'
ROUTE_OUT = TMP_DIR + '/route-n.out'
ARP_OUT = TMP_DIR + '/arp-n.out'
NETSTAT_OUT = TMP_DIR + '/netstat-an.out'
IPTABLES_OUT = TMP_DIR + '/iptables-nL.out'
BRCTL_SHOW_OUT =  TMP_DIR + '/brctl-show.out'
BRCTL_SHOWMACS_OUT = TMP_DIR + '/brctl-showmacs-%s.out'
PS_OUT = TMP_DIR + '/ps-wwwaxf.out'
DMESG_OUT = TMP_DIR + '/dmesg.out'
OPT_XENSOURCE_LISTING = TMP_DIR + '/opt-xensource.list'
XAPI_STATE_DB = TMP_DIR + '/state.db'
XAPI_STATE_DB_GENERATION = TMP_DIR + '/state.db.generation'
XENSTORE_LS_OUT = TMP_DIR + '/xenstore-ls.out'
XEN_BALLOON_OUT = TMP_DIR + '/proc/xen-balloon.out'
RPM_QA_OUT = TMP_DIR + '/rpm-qa.out'

#
# External programs
#

ARP = '/sbin/arp'
BRCTL = '/usr/sbin/brctl'
CAT = '/bin/cat'
DF = '/bin/df'
DMESG = '/bin/dmesg'
DMIDECODE = '/usr/sbin/dmidecode'
FDISK = '/sbin/fdisk'
HDPARM = '/sbin/hdparm'
IFCONFIG = '/sbin/ifconfig'
IPTABLES = '/sbin/iptables'
ISCSIADM = '/sbin/iscsiadm'
LS = '/bin/ls'
LSPCI = '/sbin/lspci'
LSUSB = '/usr/sbin/lsusb -v 2>/dev/null || '+CAT+' /proc/bus/usb/devices'
LVS = '/usr/sbin/lvs'
MD5SUM = '/usr/bin/md5sum'
NETSTAT = '/bin/netstat'
PS = '/bin/ps'
PVS = '/usr/sbin/pvs'
ROUTE = '/sbin/route'
RPM = '/bin/rpm'
SQLITE = '/usr/bin/sqlite3'
SYSCTL = '/sbin/sysctl'
UPTIME = '/usr/bin/uptime'
VGS = '/usr/sbin/vgs'
VGSCAN = '/sbin/vgscan'
XAPI_DB_PROCESS = '/opt/xensource/bin/xapi-db-process'
XENSTORE_LS = '/usr/bin/xenstore-ls'
ZCAT = '/bin/zcat'

#
# PII -- Personally identifiable information.  Of particular concern are
# things that would identify customers, or their network topology.
# Passwords are never to be included in any bug report, regardless of any PII
# declaration.
#
# NO            -- No PII will be in these entries.
# YES           -- PII will likely or certainly be in these entries.
# MAYBE         -- The user may wish to audit these entries for PII.
# IF_CUSTOMIZED -- If the files are unmodified, then they will contain no PII,
# but since we encourage customers to edit these files, PII may have been
# introduced by the customer.  This is used in particular for the networking
# scripts in dom0.
#

PII_NO            = 'no'
PII_YES           = 'yes'
PII_MAYBE         = 'maybe'
PII_IF_CUSTOMIZED = 'if_customized'

KEY      = 0
PII      = 1
MIN_SIZE = 2
MAX_SIZE = 3
MIN_TIME = 4
MAX_TIME = 5
MIME     = 6
CHECKED  = 7

MIME_DATA = 'application/data'
MIME_TEXT = 'text/plain'

INVENTORY_XML_ROOT = "system-status-inventory"
INVENTORY_XML_SUMMARY = 'system-summary'
INVENTORY_XML_ELEMENT = 'inventory-entry'
CAP_XML_ROOT = "system-status-capabilities"
CAP_XML_ELEMENT = 'capability'


CAP_BOOT_LOADER          = 'boot-loader'
CAP_DISK_INFO            = 'disk-info'
CAP_FIRSTBOOT            = 'firstboot'
CAP_HARDWARE_INFO        = 'hardware-info'
CAP_HDPARM_T             = 'hdparm-t'
CAP_HOST_CRASHDUMP_DUMPS = 'host-crashdump-dumps'
CAP_HOST_CRASHDUMP_LOGS  = 'host-crashdump-logs'
CAP_KERNEL_INFO          = 'kernel-info'
CAP_NETWORK_CONFIG       = 'network-config'
CAP_NETWORK_STATUS       = 'network-status'
CAP_PROCESS_LIST         = 'process-list'
CAP_SYSTEM_LOGS          = 'system-logs'
CAP_TAPDISK_LOGS         = 'tapdisk-logs'
CAP_X11_LOGS             = 'X11'
CAP_XAPI_SUBPROCESS      = 'xapi-subprocess'
CAP_XENSERVER_CONFIG     = 'xenserver-config'
CAP_XENSERVER_DATABASES  = 'xenserver-databases'
CAP_XENSERVER_INSTALL    = 'xenserver-install'
CAP_XENSERVER_LOGS       = 'xenserver-logs'
CAP_XEN_INFO             = 'xen-info'
CAP_YUM                  = 'yum'

KB = 1024
MB = 1024 * 1024

caps = {}


def cap(key, pii=PII_MAYBE, min_size=-1, max_size=-1, min_time=-1,
        max_time=-1, mime=MIME_TEXT, checked=True):
    caps[key] = (key, pii, min_size, max_size, min_time, max_time, mime,
                 checked)


cap(CAP_BOOT_LOADER,         PII_NO,                    max_size=3*KB,
    max_time=5)
cap(CAP_DISK_INFO,           PII_MAYBE,                 max_size=15*KB,
    max_time=20)
cap(CAP_FIRSTBOOT,           PII_YES,   min_size=60*KB, max_size=80*KB)
cap(CAP_HARDWARE_INFO,       PII_MAYBE,                 max_size=18*KB,
    max_time=5)
cap(CAP_HDPARM_T,            PII_NO,    min_size=0,     max_size=KB,
    min_time=20, max_time=60, checked=False)
cap(CAP_HOST_CRASHDUMP_DUMPS,PII_YES, checked = False)
cap(CAP_HOST_CRASHDUMP_LOGS, PII_NO)
cap(CAP_KERNEL_INFO,         PII_MAYBE,                 max_size=80*KB,
    max_time=5)
cap(CAP_NETWORK_CONFIG,      PII_IF_CUSTOMIZED,
                                        min_size=0,     max_size=10*KB)
cap(CAP_NETWORK_STATUS,      PII_YES,                   max_size=19*KB,
    max_time=5)
cap(CAP_PROCESS_LIST,        PII_YES,                   max_size=10*KB,
    max_time=10, checked=False)
cap(CAP_SYSTEM_LOGS,         PII_MAYBE,                 max_size=50*MB)
cap(CAP_TAPDISK_LOGS,        PII_NO,                    max_size=64*KB)
cap(CAP_X11_LOGS,            PII_NO,                    max_size=100*KB)
cap(CAP_XAPI_SUBPROCESS,     PII_NO,                    max_size=KB,
    max_time=10)
cap(CAP_XENSERVER_CONFIG,    PII_MAYBE,                 max_size=1*KB,
    max_time=5)
cap(CAP_XENSERVER_DATABASES, PII_YES,   min_size=500*KB,max_size=2*MB,
    max_time=20, mime=MIME_DATA)
cap(CAP_XENSERVER_INSTALL,   PII_MAYBE, min_size=10*KB, max_size=50*KB)
cap(CAP_XENSERVER_LOGS,      PII_MAYBE, min_size=0,     max_size=50*MB)
cap(CAP_XEN_INFO,            PII_MAYBE,                 max_size=5*KB,
    max_time=10)
cap(CAP_YUM,                 PII_IF_CUSTOMIZED,         max_size=5*KB,
    max_time=30)


FILES_TO_SEND = []
COMMANDS_TO_RUN = []
ANSWER_YES_TO_ALL = False
SILENT_MODE = False
entries = None
bugball = []
bugball_inventory = {}

def output(x):
    global SILENT_MODE
    if not(SILENT_MODE):
        print x

def output_ts(x):
    output("[%s]  %s" % (time.strftime("%x %X %Z"), x))

def send(e, files):
    if e in entries:
        FILES_TO_SEND.extend(files)
        bugball_inventory.update(dict([(f, e) for f in files
                                       if os.path.exists(f)]))

def send_all(e, dir, pattern = None, negate = False):
    if os.path.exists(dir):
        for f in os.listdir(dir):
            fn = os.path.join(dir, f)
            if os.path.isfile(fn) and matches(fn, pattern, negate):
                send(e, [fn])
            elif os.path.isdir(fn):
                send_all(e, fn, pattern, negate)

def cmd(e, commands):
    if e in entries:
        COMMANDS_TO_RUN.extend([ProcOutput("%s %s" % (c[0], c[1]), c[2], caps[e][MAX_TIME]) for c in commands])
        FILES_TO_SEND.extend([c[2] for c in commands])
        bugball_inventory.update(dict([(c[2], e) for c in commands]))

def do(n, e, f):
    if e in entries:
        try:
            s = f()
        except Exception, exn:
            s = str(exn)
        bugball.append(string_iterator(n, s))
        bugball_inventory[n] = e


def main(argv = None):
    global TMP_DIR
    global ANSWER_YES_TO_ALL, SILENT_MODE, FILES_TO_SEND, COMMANDS_TO_RUN
    global entries, bugball, bugball_inventory

    # we need access to privileged files, exit if we are not running as root
    if os.getuid() != 0:
        print >>sys.stderr, "Error: xen-bugtool must be run as root"
        return 1

    output_type = 'tar.bz2'
    output_fd = -1
    
    if argv is None:
        argv = sys.argv

    try:
        (options, params) = getopt.gnu_getopt(
            argv, 'sy', ['capabilities', 'silent', 'yestoall', 'entries=',
                         'output=', 'outfd='])
    except getopt.GetoptError, opterr:
        print >>sys.stderr, opterr
        return 2

    entries = caps.keys()

    for (k, v) in options:
        if k == '--capabilities':
            update_capabilities()
            print_capabilities()
            return 0

        if k == '--output':
            for vv in ['tar', 'tar.bz2', 'zip']:
                if v == vv:
                    output_type = v
                    break

        # "-s" or "--silent" means suppress output (except for the final
        # output filename at the end)
        if k in ['-s', '--silent']:
            SILENT_MODE = True

        if k == '--entries' and v != '':
            entries = v.split(',')

        # If the user runs the script with "-y" or "--yestoall" we don't ask
        # all the really annoying questions.
        if k in ['-y', '--yestoall']:
            ANSWER_YES_TO_ALL = True  

        if k == '--outfd':
            output_fd = int(v)

    if len(params) != 1:
        print >>sys.stderr, "Invalid additional arguments", str(params)
        return 2

    if output_fd != -1 and output_type != 'tar':
        print >>sys.stderr, "Option '--outfd' only valid with '--output=tar'"
        return 2

    if ANSWER_YES_TO_ALL:
        output("Warning: '--yestoall' argument provided, will not prompt for individual files.")

    output('''
This application will collate the Xen dmesg output, details of the
hardware configuration of your machine, information about the build of
Xen that you are using, plus, if you allow it, various logs.

The collated information will be saved as a .%s for archiving or
sending to a Technical Support Representative.

The logs may contain private information, and if you are at all
worried about that, you should exit now, or you should explicitly
exclude those logs from the archive.

''' % output_type)

    if not os.path.exists(TMP_DIR):
        os.makedirs(TMP_DIR)
    if not os.path.exists(TMP_DIR + '/proc'):
        os.makedirs(TMP_DIR + '/proc')

    xc = xen.lowlevel.xc.xc()

    send(CAP_BOOT_LOADER, [GRUB_CONFIG])
    cmd(CAP_BOOT_LOADER, [[LS, '-lR', BOOT_LISTING],
                          [MD5SUM, '%s %s' % (BOOT_KERNEL, BOOT_INITRD), BOOT_MD5SUMS]])

    cmd(CAP_DISK_INFO, [[FDISK, '-l', FDISK_OUT]])
    cmd(CAP_DISK_INFO, [[CAT, PROC_PARTITIONS, PARTITIONS_OUT],
                        [CAT, PROC_MOUNTS, MOUNTS_OUT]])
    send(CAP_DISK_INFO, [FSTAB, ISCSI_CONF, ISCSI_INITIATOR])
    cmd(CAP_DISK_INFO, [[DF, '-alT', DF_OUT], [DF, '-alTi', DFI_OUT]])
    for d in disk_list():
        cmd(CAP_DISK_INFO, [[HDPARM, '-I /dev/%s' % d, HDPARM_I_OUT % d]])
    cmd(CAP_DISK_INFO, [[ISCSIADM, '-m node', ISCSI_NODE_OUT]])
    if CAP_DISK_INFO in entries:
        output_ts("Scanning volume groups")
        vgp = ProcOutput(VGSCAN, '/dev/null', caps[CAP_DISK_INFO][MAX_TIME])
        run_procs([vgp])
        if not (vgp.timed_out or vgp.failed):
            cmd(CAP_DISK_INFO, [[PVS, '', PVS_OUT], [VGS, '', VGS_OUT], [LVS, '', LVS_OUT]])
            send(CAP_DISK_INFO, [LVM_CACHE])
    send_all(CAP_FIRSTBOOT, FIRSTBOOT_DIR)

    cmd(CAP_HARDWARE_INFO, [[CAT, PROC_CPUINFO, CPUINFO_OUT], 
                            [CAT, PROC_MEMINFO, MEMINFO_OUT], 
                            [CAT, PROC_IOPORTS, IOPORTS_OUT], 
                            [CAT, PROC_INTERRUPTS, INTERRUPTS_OUT]])
    cmd(CAP_HARDWARE_INFO, [[DMIDECODE, '', DMI_OUT], [LSPCI, '-n', LSPCI_N_OUT], 
                            [LSPCI, '-vv', LSPCI_VV_OUT], [LSUSB, '', LSUSB_OUT],
                            [CAT, PROC_SCSI, SCSI_OUT]])
    # FIXME IDE?

    for d in disk_list():
        cmd(CAP_HDPARM_T, [[HDPARM, '-tT /dev/%s' % d, HDPARM_TT_OUT % d]])

    send_all(CAP_HOST_CRASHDUMP_DUMPS, HOST_CRASHDUMPS_DIR,
             HOST_CRASHDUMP_LOGS_RE, True)
    send_all(CAP_HOST_CRASHDUMP_LOGS,  HOST_CRASHDUMPS_DIR,
             HOST_CRASHDUMP_LOGS_RE, False)

    cmd(CAP_KERNEL_INFO, [[CAT, PROC_VERSION, VERSION_OUT], [CAT, PROC_MODULES, MODULES_OUT], 
                          [CAT, PROC_DEVICES, DEVICES_OUT], [CAT, PROC_FILESYSTEMS, FILESYSTEMS_OUT]])
    cmd(CAP_KERNEL_INFO, [[CAT, PROC_CMDLINE, CMDLINE_OUT], [ZCAT, PROC_CONFIG, CONFIG_OUT],
                          [SYSCTL, '-A', SYSCTL_OUT]])

    # Add the network config scripts to FILES_TO_SEND
    send_all(CAP_NETWORK_CONFIG, SYSCONFIG_NETWORK_SCRIPTS, IFCFG_RE)
    send(CAP_NETWORK_CONFIG, [SYSCONFIG_NETWORK, RESOLV_CONF, NSSWITCH_CONF])
    send(CAP_NETWORK_CONFIG, [NTP_CONF, IPTABLES_CONFIG, HOSTS_ALLOW, HOSTS_DENY])

    cmd(CAP_NETWORK_STATUS,[[IFCONFIG, '-a', IFCONFIG_OUT], [ROUTE, '-n', ROUTE_OUT],
                            [ARP, '-n', ARP_OUT], [NETSTAT, '-an', NETSTAT_OUT]])
    send_all(CAP_NETWORK_STATUS, DHCP_LEASE_DIR)
    cmd(CAP_NETWORK_STATUS,[[IPTABLES, '-nL', IPTABLES_OUT], [BRCTL, 'show', BRCTL_SHOW_OUT]])
    for p in os.listdir('/sys/class/net/'):
        if os.path.isdir('/sys/class/net/%s/bridge' % p):
            cmd(CAP_NETWORK_STATUS,
                [[BRCTL, 'showmacs %s' % p, BRCTL_SHOWMACS_OUT % p]])

    cmd(CAP_PROCESS_LIST, [[PS, 'wwwaxf -eo pid,tty,stat,time,nice,psr,pcpu,pmem,wchan:25,args', PS_OUT]])

    send(CAP_SYSTEM_LOGS,
         [ VAR_LOG_DIR + x for x in
           [ 'syslog', 'messages', 'debug', 'dmesg', 'boot.msg' ] +
           [ 'messages.%d' % y for y in range(1,20)]])
    if not os.path.exists('/var/log/dmesg') and not os.path.exists('/var/log/boot.msg'):
        cmd(CAP_SYSTEM_LOGS, [[DMESG, '', DMESG_OUT]])

    if CAP_TAPDISK_LOGS in entries:
        generate_tapdisk_logs()

    send_all(CAP_X11_LOGS, X11_LOGS_DIR, X11_LOGS_RE)

    do('xapi-subprocesses', CAP_XAPI_SUBPROCESS, lambda: dump_xapi_subprocess_info())

    send(CAP_XENSERVER_CONFIG, [POOL_CONF, XAPI_CONF, XAPI_SSL_CONF, XENSOURCE_INVENTORY, VENDORKERNEL_INVENTORY])
    cmd(CAP_XENSERVER_CONFIG, [[LS, '-lR', OPT_XENSOURCE_LISTING]])

    if CAP_XENSERVER_DATABASES in entries:
        get_and_sanitize_databases()
    send(CAP_XENSERVER_DATABASES,
         [XAPI_STATE_DB, XAPI_STATE_DB_GENERATION, XAPI_LOCAL_DB])
    cmd(CAP_XENSERVER_DATABASES, [[XENSTORE_LS, '', XENSTORE_LS_OUT]])

    send(CAP_XENSERVER_INSTALL,
         [ VAR_LOG_DIR + x for x in 
           [ 'firstboot-SR-commands-log',
             'upgrade-commands-log', 'generate-iscsi-iqn-log']] +
         [ '/root/' + x for x in 
           [ 'blockdevs-log', 'cmdline-log', 'devcontents-log',
             'dmesg-log', 'install-log', 'lspci-log', 'modules-log',
             'pci-log', 'processes-log', 'tty-log', 'uname-log',
             'vgscan-log']])

    send(CAP_XENSERVER_LOGS, XENSERVER_LOGS)

    do('xen-dmesg', CAP_XEN_INFO, lambda: xc.readconsolering())
    do('physinfo',  CAP_XEN_INFO, lambda: prettyDict(xc.physinfo()))
    do('xeninfo',   CAP_XEN_INFO, lambda: prettyDict(xc.xeninfo()))
    cmd(CAP_XEN_INFO,
        [[CAT, '/proc/xen/balloon', XEN_BALLOON_OUT]])

    send(CAP_YUM, [YUM_LOG])
    send_all(CAP_YUM, YUM_REPOS_DIR)
    cmd(CAP_YUM, [[RPM, '-qa', RPM_QA_OUT]])
    
    output_ts('Running commands to collect data')
    run_procs(COMMANDS_TO_RUN)

    for filename in FILES_TO_SEND:
        if not os.path.exists(filename):
            continue

        if ANSWER_YES_TO_ALL or yes('Include %s? [Y/n] ' % filename):
            bugball.append(file(filename))

    if not os.path.exists(BUG_DIR):
        os.makedirs(BUG_DIR)

    if output_type == 'tar.bz2' or output_type == 'tar':
        make_tar(output_type, output_fd)
    else:
        make_zip()

    shutil.rmtree(TMP_DIR, ignore_errors = True)
    clean_tapdisk_logs()
    return 0

def generate_tapdisk_logs():
    pids = commands.getoutput("/bin/ps -C tapdisk -o pid=")
    for pid in pids.split():
        output_ts("Including logs for tapdisk process %s" % pid)
	try:
	    os.kill(int(pid), SIGUSR1)
	    FILES_TO_SEND.append("/tmp/tapdisk.log." + pid)
        except Exception, exn:
            print >>sys.stderr, exn
    # give processes a second to write their logs
    time.sleep(1)

def clean_tapdisk_logs():
    for filename in FILES_TO_SEND:
        if filename.startswith("/tmp/tapdisk.log"):
            try:
                os.remove(filename)
            except Exception, exn:
                print >>sys.stderr, exn

def dump_xapi_subprocess_info():
    """Check which fds are open by xapi and its subprocesses to diagnose faults like CA-10543.
       Returns a string containing a pretty-printed pstree-like structure. """
    pids = filter(lambda x: os.path.exists("/proc/" + x + "/cmdline"), os.listdir("/proc"))
    def readlines(filename):
    	f = open(filename, "r")
	try:
		return f.readlines()
	finally:
		f.close()
    def cmdline(pid):
    	all = readlines("/proc/" + pid + "/cmdline")
	if all == []:
	   return ""
	else:
	   return all[0]
    def parent(pid):
    	for i in readlines("/proc/" + pid + "/status"):
	    if i.startswith("PPid:"):
	       return i.split()[-1]
	return None
    def pstree(pid):
    	result = { "cmdline": cmdline(pid) }
	child_pids = filter(lambda x:parent(x) == pid, pids)
	children = { }
	for child in child_pids:
	    children[child] = pstree(child)
	result['children'] = children
	fds = { }
	for fd in os.listdir("/proc/" + pid + "/fd"):
	    fds[fd] = os.readlink("/proc/" + pid + "/fd/" + fd)
	result['fds'] = fds
	return result	
    xapis = filter(lambda x: cmdline(x).startswith("/opt/xensource/bin/xapi"), pids)
    xapis = filter(lambda x: parent(x) == "1", xapis)
    result = {}
    for xapi in xapis:
    	result[xapi] = pstree(xapi)
    pp = pprint.PrettyPrinter(indent=4)
    return pp.pformat(result)

def get_and_sanitize_databases():
    output_ts("Dumping XAPI database")
    dbp = ProcOutput("%s -filename %s -format sqlite" % (XAPI_DB_PROCESS, XAPI_STATE_DB), '/dev/null', caps[CAP_XENSERVER_DATABASES][MAX_TIME])
    run_procs([dbp])
    if dbp.timed_out or dbp.failed:
        os.remove(XAPI_STATE_DB)
    else:
        sanitize_database(XAPI_STATE_DB)

def sanitize_database(db):
    try:
        uuids = sql(db, 'select uuid from pbd')
        for uuid in uuids:
            uuid = uuid.strip()
            dconfs = sql(db, "select device_config from pbd where uuid='%s'" % uuid)
            d = dconfs[0].strip()
            dconf = sexp.parse(d)
            for pw in ['cifspassword', 'chappassword', 'password']:
                dconf.set_assoc(pw, 'REMOVED')
            new_d = dconf.toString()
            if new_d != d:
                sql(db, "update pbd set device_config='%s' where uuid='%s'" % (new_d.replace("'", "''"), uuid))
    except Exception, exn:
        print >>sys.stderr, exn
        os.remove(db)


def sql(db, sql):
    result = []
    inp, out = os.popen2([SQLITE, db, sql])
    try:
        for line in out:
            result.append(line)
        return result
    finally:
        inp.close()
        out.close()


def make_tar(suffix, output_fd):
    global SILENT_MODE, bugball, bugball_inventory

    mode = 'w'
    if suffix == 'tar.bz2':
        mode = 'w:bz2'
    date_string = time.strftime("%Y%m%d%H%M%S")

    filename = "%s/bug-report-%s.%s" % (BUG_DIR, date_string, suffix)
    subdir = "bug-report-%s" %  date_string

    bugball.append(string_iterator('inventory.xml',
                                   make_inventory(bugball_inventory, subdir)))

    now = time.time()

    if output_fd == -1:
        tf = tarfile.open(filename, mode)
    else:
        tf = tarfile.open(None, 'w', os.fdopen(output_fd, 'a'))

    try:
        for f in bugball:
            tar_filename = os.path.join(subdir, truncated_name(f.name))
            ti = tarfile.TarInfo(tar_filename)

            if hasattr(f, 'size'):
                ti.size = f.size()
            else:
                ti.size = os.stat(f.name).st_size

            ti.mtime = now
            ti.type = tarfile.REGTYPE
            ti.uid = 0
            ti.gid = 0
            ti.uname = 'root'
            ti.gname = 'root'

            f.seek(0) # If we've added this file to a bug, it will have been
                      # read once already, so reset it.
            tf.addfile(ti, f)
    finally:
        tf.close()

    if output_fd == -1:
        output ('Writing tarball %s successful.' % filename)
        if SILENT_MODE:
            print filename


def make_zip():
    global SILENT_MODE, bugball, bugball_inventory

    date_string = time.strftime("%Y%m%d%H%M%S")

    filename = "%s/bug-report-%s.zip" % (BUG_DIR, date_string)
    subdir = "bug-report-%s" %  date_string

    bugball.append(string_iterator('inventory.xml',
                                   make_inventory(bugball_inventory, subdir)))

    zf = zipfile.ZipFile(filename, 'w', zipfile.ZIP_DEFLATED)

    try:
        for f in bugball:
            dest = os.path.join(subdir, truncated_name(f.name))

            if os.path.exists(f.name):
                compress_type = zipfile.ZIP_DEFLATED
                if os.stat(f.name).st_size < 50:
                    compress_type = zipfile.ZIP_STORED
                zf.write(f.name, dest, compress_type)
            elif hasattr(f, 'getvalue'):
                zf.writestr(dest, f.getvalue())
    finally:
        zf.close()
    
    output ('Writing archive %s successful.' % filename)
    if SILENT_MODE:
        print filename


def make_inventory(inventory, subdir):
    document = getDOMImplementation().createDocument(
        None, INVENTORY_XML_ROOT, None)

    # create summary entry
    s = document.createElement(INVENTORY_XML_SUMMARY)
    user = os.getenv('SUDO_USER', os.getenv('USER'))
    if user != None:
        s.setAttribute('user', user)
    s.setAttribute('date', time.strftime('%c'))
    s.setAttribute('hostname', platform.node())
    s.setAttribute('uname', ' '.join(platform.uname()))
    s.setAttribute('uptime', commands.getoutput(UPTIME))
    document.getElementsByTagName(INVENTORY_XML_ROOT)[0].appendChild(s)

    map(lambda (f, e): inventory_entry(document, subdir, f, e),
        inventory.iteritems())
    return document.toprettyxml()

def inventory_entry(document, subdir, filename, capability):
    el = document.createElement(INVENTORY_XML_ELEMENT)
    if os.path.exists(filename):
        try:
            el.setAttribute('md5sum', md5sum(filename))
        except:
            pass
    el.setAttribute('filename',
                    os.path.join(subdir, truncated_name(filename)))
    el.setAttribute('capability', capability)
    document.getElementsByTagName(INVENTORY_XML_ROOT)[0].appendChild(el)


def md5sum(fn):
    m = md5.new()
    f = open(fn)
    data = f.read(1024)
    while len(data) > 0:
        m.update(data)
        data = f.read(1024)
    f.close()
    return m.hexdigest()


def truncated_name(f):
    if f.startswith(TMP_DIR):
        return f.replace(TMP_DIR + os.path.sep, '')
    elif f.startswith(os.path.sep):
        return f[1:]
    return f


def update_capabilities():
    update_cap_size(CAP_HOST_CRASHDUMP_LOGS,
                    size_of_dir(HOST_CRASHDUMPS_DIR, HOST_CRASHDUMP_LOGS_RE))
    update_cap_size(CAP_HOST_CRASHDUMP_DUMPS,
                    size_of_dir(HOST_CRASHDUMPS_DIR, HOST_CRASHDUMP_LOGS_RE,
                                True))
    update_cap_size(CAP_XENSERVER_LOGS,  size_of_all(XENSERVER_LOGS))


def update_cap_size(cap, size):
    update_cap(cap, MIN_SIZE, size)
    update_cap(cap, MAX_SIZE, size)
    update_cap(cap, CHECKED, size > 0)


def update_cap(cap, k, v):
    global caps
    l = list(caps[cap])
    l[k] = v
    caps[cap] = tuple(l)


def size_of_dir(d, pattern = None, negate = False):
    if os.path.isdir(d):
        return size_of_all([os.path.join(d, fn) for fn in os.listdir(d)],
                           pattern, negate)
    else:
        return 0


def size_of_all(files, pattern = None, negate = False):
    return sum([size_of(f, pattern, negate) for f in files])


def matches(f, pattern, negate):
    if negate:
        return not matches(f, pattern, False)
    else:
        return pattern is None or pattern.match(f)


def size_of(f, pattern, negate):
    if os.path.isfile(f) and matches(f, pattern, negate):
        return os.stat(f)[6]
    else:
        return size_of_dir(f, pattern, negate)


def print_capabilities():
    document = getDOMImplementation().createDocument(
        "ns", CAP_XML_ROOT, None)
    map(lambda key: capability(document, key), caps.keys())
    print document.toprettyxml()

def capability(document, key):
    c = caps[key]
    el = document.createElement(CAP_XML_ELEMENT)
    el.setAttribute('key', c[KEY])
    el.setAttribute('pii', c[PII])
    el.setAttribute('min-size', str(c[MIN_SIZE]))
    el.setAttribute('max-size', str(c[MAX_SIZE]))
    el.setAttribute('min-time', str(c[MIN_TIME]))
    el.setAttribute('max-time', str(c[MAX_TIME]))
    el.setAttribute('content-type', c[MIME])
    el.setAttribute('default-checked', c[CHECKED] and 'yes' or 'no')
    document.getElementsByTagName(CAP_XML_ROOT)[0].appendChild(el)


def prettyDict(d):
    format = '%%-%ds: %%s' % max(map(len, [k for k, _ in d.items()]))
    return '\n'.join([format % i for i in d.items()]) + '\n'


class string_iterator(StringIO.StringIO):
    def __init__(self, name, val):
        StringIO.StringIO.__init__(self, val)
        self.name = name

    def size(self):
        return len(self.getvalue())


def yes(prompt):
    yn = raw_input(prompt)

    return len(yn) == 0 or yn.lower()[0] == 'y'


partition_re = re.compile(r'.*[0-9]+$')

def disk_list():
    disks = []
    f = open('/proc/partitions')
    f.readline()
    f.readline()
    for line in f.readlines():
        (major, minor, blocks, name) = line.split()
        if int(major) < 254 and not partition_re.match(name):
            disks.append(name)
    return disks


class ProcOutput:
    def __init__(self, command, output, max_time):
        self.command = command
        self.output = output
        self.max_time = max_time
        self.running = False
        self.timed_out = False
        self.failed = False

    def __del__(self):
        self.terminate()

    def run(self):
        self.outfile = open(self.output, 'w')
        self.proc = Popen(self.command + ' 2>/dev/null', 1, stdout=PIPE, shell=True)
        self.timeout = int(time.time()) + self.max_time
        self.running = True
        self.timed_out = False
        self.failed = False

    def terminate(self):
        if self.running:
            try:
                os.kill(self.proc.pid, SIGTERM)
            except:
                pass
            self.outfile.close()
            self.running = False

    def read_line(self):
        assert self.running
        line = self.proc.stdout.readline()
        if line == '':
            # process exited
            self.outfile.close()
            if self.proc.wait() == 127:
                # command not found
                os.remove(self.output)
                self.failed = True
                output_ts("%s failed" % self.command)
            self.running = False
        else:
            self.outfile.write(line)

def run_procs(procs):
    # launch all processes
    for p in procs:
        p.run()

    while len(procs) > 0:
        pipes = [p.proc.stdout for p in procs if p.running]
        if len(pipes) == 0:
            # all finished
            return

        (i, o, x) = select(pipes, [], [], 1.0)
        now = int(time.time())

        # handle process output
        for p in procs:
            if p.proc.stdout in i:
                p.read_line()

            # handle timeout
            if p.running and now > p.timeout:
                output_ts("%s timed out" % p.command)
                p.timed_out = True
                p.outfile.write("\n** timeout **\n")
                p.terminate()


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print "\nInterrupted."
        shutil.rmtree(TMP_DIR, ignore_errors = True)
        sys.exit(3)
