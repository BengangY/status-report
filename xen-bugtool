#!/usr/bin/env python

# This library is free software; you can redistribute it and/or
# modify it under the terms of version 2.1 of the GNU Lesser General Public
# License as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Copyright (c) 2005, 2007 XenSource Ltd.


import errno
import getopt
import getpass
import httplib
import re
import os
import os.path
import string
import StringIO
import sys
import tarfile
import tempfile
import time
import urllib
import commands
import signal
from xml.dom.minidom import parse, getDOMImplementation

sys.path.append('/usr/lib/python')
sys.path.append('/usr/lib64/python')

import sexp
import xen.lowlevel.xc


PII_NO            = 'no'
PII_YES           = 'yes'
PII_MAYBE         = 'maybe'
PII_IF_CUSTOMIZED = 'if_customized'

KEY      = 0
PII      = 1
MIN_SIZE = 2
MAX_SIZE = 3
MIN_TIME = 4
MAX_TIME = 5
MIME     = 6
CHECKED  = 7

MIME_DATA = 'application/data'
MIME_TEXT = 'text/plain'

INVENTORY_XML_ROOT = "system-status-inventory"
INVENTORY_XML_ELEMENT = 'inventory-entry'
CAP_XML_ROOT = "system-status-capabilities"
CAP_XML_ELEMENT = 'capability'


CAP_HDPARM_T             = 'HDPARM_T'
CAP_HOST_CRASHDUMP_DUMPS = 'HOST_CRASHDUMP_DUMPS'
CAP_HOST_CRASHDUMP_LOGS  = 'HOST_CRASHDUMP_LOGS'
CAP_NETWORK_CONFIG       = 'NETWORK_CONFIG'
CAP_NETWORK_STATUS       = 'NETWORK_STATUS'
CAP_SYSTEM_INFO          = 'SYSTEM_INFO'
CAP_SYSTEM_LOGS          = 'SYSTEM_LOGS'
CAP_TAPDISK_LOGS         = 'TAPDISK_LOGS'
CAP_XENSERVER_CONFIG     = 'XENSERVER_CONFIG'
CAP_XENSERVER_DATABASES  = 'XENSERVER_DATABASES'
CAP_XENSERVER_INSTALL    = 'XENSERVER_INSTALL'
CAP_XENSERVER_LOGS       = 'XENSERVER_LOGS'
CAP_XEN_INFO             = 'XEN_INFO'
CAP_YUM                  = 'YUM'

KB = 1024
MB = 1024 * 1024

caps = {}


def cap(key, pii=PII_MAYBE, min_size=-1, max_size=-1, min_time=-1,
        max_time=-1, mime=MIME_TEXT, checked=True):
    caps[key] = (key, pii, min_size, max_size, min_time, max_time, mime,
                 checked)


cap(CAP_HDPARM_T,            PII_NO,    min_size=0,     max_size=KB,
    min_time=120, max_time=600, checked=False)
cap(CAP_HOST_CRASHDUMP_DUMPS,PII_YES, checked = False)
cap(CAP_HOST_CRASHDUMP_LOGS, PII_NO)
cap(CAP_NETWORK_CONFIG,      PII_IF_CUSTOMIZED,
                                        min_size=0,     max_size=10*KB)
cap(CAP_NETWORK_STATUS,      PII_YES,                   max_size=2*KB)
cap(CAP_SYSTEM_INFO,         PII_MAYBE,                 max_size=KB)
cap(CAP_SYSTEM_LOGS,         PII_MAYBE,                 max_size=50*MB)
cap(CAP_TAPDISK_LOGS,        PII_NO,                    max_size=KB)
cap(CAP_XENSERVER_CONFIG,    PII_MAYBE,                 max_size=1*KB)
cap(CAP_XENSERVER_DATABASES, PII_YES,   min_size=500*KB,max_size=2*MB,
    mime=MIME_DATA)
cap(CAP_XENSERVER_INSTALL,   PII_MAYBE, min_size=10*KB, max_size=50*KB)
cap(CAP_XENSERVER_LOGS,      PII_MAYBE, min_size=0,     max_size=50*MB)
cap(CAP_XEN_INFO,            PII_MAYBE,                 max_size=5*KB)
cap(CAP_YUM,                 PII_IF_CUSTOMIZED,         max_size=5*KB)


def read_kvpairs(filename):
   """Read in a file of key-value pairs in the format used by the inventory file"""
   f = open(filename)
   all = {}
   try:
        for line in f.readlines():
            equals = line.index("=")    
            key = line[0:equals]
            value = line[equals+1:].strip().strip("'")
            all[key] = value
   finally:
        f.close()
        return all
# read the /etc/xensource-inventory file if it exists
def read_inventory():
    try:
        return read_kvpairs("/etc/xensource-inventory")  
    except:
        return {}


SQLITE = '/usr/bin/sqlite3'

SYSTEM_INFO_SCRIPT = '/usr/sbin/system-info.sh'
SYSTEM_INFO_SCRIPT_OUTPUT = '/tmp/system-info.out'

IPTABLES_CONFIG = '/etc/sysconfig/iptables-config'

NETWORK_SCRIPTS_DIR = '/etc/sysconfig/network-scripts'

YUM_REPOS_DIR = '/etc/yum.repos.d'

DHCP_LEASE_DIR = '/var/lib/dhclient'

XAPI_LOCAL_DB = '/var/xapi/local.db'
XAPI_STATE_DB = '/tmp/state.db'
XAPI_STATE_DB_GENERATION = '/tmp/state.db.generation'
XAPI_DB_PROCESS = '/opt/xensource/bin/xapi-db-process'

POOL_CONF = '/etc/xensource/pool.conf'

HDPARM = '/sbin/hdparm'

HOST_CRASHDUMPS_DIR = '/var/crash'
HOST_CRASHDUMP_LOGS_RE = re.compile(r'^.*\.log$')

XENSERVER_LOGS = \
    [ '/var/log/' + x for x in
      ['xensource.log', 'SMlog'] +
      ['xensource.log.%d' % y for y in range(1,21)] +
      ['SMlog.%d' % y for y in range(1,20)] +
      ['xen/xenstored-trace.log',
       'xen/xen-hotplug.log',
       'xen/domain-builder-ng.log'] +
      [ 'xen/xenstored-access.log.%d' % y for y in range(1,20)]]

# Key in the inventory file which maps to a space-separated list of 
# physical devices
DEFAULT_SR_PHYSDEVS = 'DEFAULT_SR_PHYSDEVS'


FILES_TO_SEND = []
COMMANDS_TO_RUN = []
ANSWER_YES_TO_ALL = False
SILENT_MODE = False
entries = None
bugball = []
bugball_inventory = {}


def output(x):
    global SILENT_MODE
    if not(SILENT_MODE):
        print x

def send(e, files):
    if e in entries:
        FILES_TO_SEND.extend(files)
        bugball_inventory.update(dict([(f, e) for f in files
                                       if os.path.exists(f)]))

def send_all(e, dir, pattern, negate):
    if os.path.exists(dir):
        for f in os.listdir(dir):
            fn = os.path.join(dir, f)
            if os.path.isfile(fn) and matches(fn, pattern, negate):
                send(e, [fn])
            elif os.path.isdir(fn):
                send_all(e, fn, pattern, negate)

def cmd(e, commands):
    if e in entries:
        COMMANDS_TO_RUN.extend(commands)
        FILES_TO_SEND.append(c[2])
        bugball_inventory.update(dict([(c[2], e) for c in commands]))

def do(n, e, f):
    if e in entries:
        try:
            s = f()
        except Exception, exn:
            s = str(exn)
        bugball.append(string_iterator(n, s))
        bugball_inventory[n] = e


def main(argv = None):
    global ANSWER_YES_TO_ALL, SILENT_MODE, FILES_TO_SEND, COMMANDS_TO_RUN
    global entries, bugball, bugball_inventory
    
    if argv is None:
        argv = sys.argv

    try:
        (options, params) = getopt.gnu_getopt(
            argv, 'sy', ['capabilities', 'silent', 'yestoall', 'entries='])
    except getopt.GetoptError, opterr:
        print >>sys.stderr, opterr
        return 127

    entries = caps.keys()

    for (k, v) in options:
        if k == '--capabilities':
            update_capabilities()
            print_capabilities()
            return 0

        # "-s" or "--silent" means suppress output (except for the final
        # output filename at the end)
        if k in ['-s', '--silent']:
            SILENT_MODE = True

        if k == '--entries':
            entries = v.split(',')

        # If the user runs the script with "-y" or "--yestoall" we don't ask
        # all the really annoying questions.
        if k in ['-y', '--yestoall']:
            ANSWER_YES_TO_ALL = True  
            output("Warning: '--yestoall' argument provided, will not prompt for individual files.")


    if len(params) != 1:
        print >>sys.stderr, "Invalid additional arguments", str(params)
        return 128


    output('''
This application will collate the Xen dmesg output, details of the
hardware configuration of your machine, information about the build of
Xen that you are using, plus, if you allow it, various logs.

The collated information will be saved as a .tar.bz2 for archiving or
sending to a Technical Support Representative.

The logs may contain private information, and if you are at all
worried about that, you should exit now, or you should explicitly
exclude those logs from the archive.

''')


    xc = xen.lowlevel.xc.xc()

    if CAP_HDPARM_T in entries:
        try:
            inventory = read_inventory()
            if DEFAULT_SR_PHYSDEVS in inventory.keys():
                for device in inventory[DEFAULT_SR_PHYSDEVS].split():
                    f = "/tmp/hdparm-tT-" + string.join(device.split("/"), "-")
                    cmd(CAP_HDPARM_T, [HDPARM, "-tT " + device, f])
        except:
            pass

    send_all(CAP_HOST_CRASHDUMP_DUMPS, HOST_CRASHDUMPS_DIR,
             HOST_CRASHDUMP_LOGS_RE, True)
    send_all(CAP_HOST_CRASHDUMP_LOGS,  HOST_CRASHDUMPS_DIR,
             HOST_CRASHDUMP_LOGS_RE, False)

    # Add the network config scripts to FILES_TO_SEND
    if (CAP_NETWORK_CONFIG in entries and
        os.path.isdir(NETWORK_SCRIPTS_DIR)):
       for f in os.listdir(NETWORK_SCRIPTS_DIR):
	   if f.startswith("ifcfg-"):
	       send(CAP_NETWORK_CONFIG,
                    [os.path.join(NETWORK_SCRIPTS_DIR, f)])
       send(CAP_NETWORK_CONFIG, [IPTABLES_CONFIG])

    send(CAP_NETWORK_STATUS,
         [os.path.join(DHCP_LEASE_DIR, x)
          for x in os.listdir(DHCP_LEASE_DIR)] +
         ['/etc/resolv.conf', '/etc/ntp.conf'])
    cmd(CAP_NETWORK_STATUS,
        [[ '/sbin/iptables', '-L', '/tmp/iptables-L.out' ],
         [ '/usr/sbin/brctl', 'show', '/tmp/brctl-show.out' ],
         [ '/sbin/ifconfig', '-a', '/tmp/ifconfig-a.out' ]])

    if CAP_SYSTEM_INFO in entries:
        run_system_info_script()
    cmd(CAP_SYSTEM_INFO,
        [[ '/sbin/lspci', '-n', '/tmp/lspci-n.out' ]])

    send(CAP_SYSTEM_LOGS,
         [ '/var/log/' + x for x in
           [ 'syslog', 'messages', 'debug' ] +
           [ 'messages.%d' % y for y in range(1,20)]])

    if CAP_TAPDISK_LOGS in entries:
        generate_tapdisk_logs()

    send(CAP_XENSERVER_CONFIG, [POOL_CONF])

    if CAP_XENSERVER_DATABASES in entries:
        get_and_sanitize_databases()
    send(CAP_XENSERVER_DATABASES,
         [XAPI_STATE_DB, XAPI_STATE_DB_GENERATION, XAPI_LOCAL_DB])

    send(CAP_XENSERVER_INSTALL,
         [ '/var/log/' + x for x in 
           [ 'firstboot-SR-commands-log',
             'upgrade-commands-log', 'generate-iscsi-iqn-log']] +
         [ '/root/' + x for x in 
           [ 'blockdevs-log', 'cmdline-log', 'devcontents-log',
             'dmesg-log', 'install-log', 'lspci-log', 'modules-log',
             'pci-log', 'processes-log', 'tty-log', 'uname-log',
             'vgscan-log']])

    send(CAP_XENSERVER_LOGS, XENSERVER_LOGS)

    do('xen-dmesg', CAP_XEN_INFO, lambda: xc.readconsolering())
    do('physinfo',  CAP_XEN_INFO, lambda: prettyDict(xc.physinfo()))
    do('xeninfo',   CAP_XEN_INFO, lambda: prettyDict(xc.xeninfo()))
    cmd(CAP_XEN_INFO,
        [[ '/bin/cat', '/proc/xen/balloon', '/tmp/proc-xen-balloon.out' ]])

    send(CAP_YUM,
         ['/var/log/yum.log'] +
         [os.path.join(YUM_REPOS_DIR, x) for x in os.listdir(YUM_REPOS_DIR)])
    cmd(CAP_YUM,
        [['/bin/rpm', '-qa', '/tmp/rpm-qa.out']])


    for c in COMMANDS_TO_RUN:
	if os.path.isfile(c[0]):
	   command = "%s %s > %s" % (c[0], c[1], c[2])
	   output("Running " + command)
	   commands.getstatusoutput(command)

    for filename in FILES_TO_SEND:
        if not os.path.exists(filename):
            continue

        if ANSWER_YES_TO_ALL or yes('Include %s? [Y/n] ' % filename):
            bugball.append(file(filename))

    tar()

    return 0

def run_system_info_script():
    if os.path.isfile(SYSTEM_INFO_SCRIPT):
        output('Gathering system information...\n')
        (status, _) = commands.getstatusoutput("%s > %s" % (SYSTEM_INFO_SCRIPT, SYSTEM_INFO_SCRIPT_OUTPUT))
        if status == 0:
            FILES_TO_SEND.append(SYSTEM_INFO_SCRIPT_OUTPUT)

def generate_tapdisk_logs():
    pids = commands.getoutput("/bin/ps -C tapdisk -o pid=")
    for pid in pids.split():
	try:
	    os.kill(int(pid), signal.SIGUSR1)
	    FILES_TO_SEND.append("/tmp/tapdisk.log." + pid)
	    FILES_TO_SEND.append("/tmp/vhd.log." + pid)
	    FILES_TO_SEND.append("/tmp/io-optimize.log." + pid)
        except Exception, exn:
            print >>sys.stderr, exn
    # give processes a second to write their logs
    time.sleep(1)


def get_and_sanitize_databases():
    status, _ = commands.getstatusoutput(
        XAPI_DB_PROCESS + " -filename '" + XAPI_STATE_DB + "' -format sqlite")
    if status:
        try:
            os.remove(XAPI_STATE_DB)
        except Exception, exn:
            print >>sys.stderr, exn
    else:
        sanitize_database(XAPI_STATE_DB)


def sanitize_database(db):
    try:
        uuids = sql(db, 'select uuid from pbd')
        for uuid in uuids:
            uuid = uuid.strip()
            dconfs = sql(db, "select device_config from pbd where uuid='%s'" % uuid)
            d = dconfs[0].strip()
            dconf = sexp.parse(d)
            dconf.set_assoc('cifspassword', 'REMOVED')
            new_d = dconf.toString()
            if new_d != d:
                sql(db, "update pbd set device_config='%s' where uuid='%s'" % (new_d.replace("'", "''"), uuid))
    except Exception, exn:
        print >>sys.stderr, exn
        os.remove(db)


def sql(db, sql):
    result = []
    inp, out = os.popen2([SQLITE, db, sql])
    try:
        for line in out:
            result.append(line)
        return result
    finally:
        inp.close()
        out.close()


def tar():
    global SILENT_MODE, bugball, bugball_inventory

    bug_dir = "/var/opt/xen/bug-report"
    if not os.path.exists(bug_dir):
        os.makedirs(bug_dir)

    date_string = time.strftime("%Y%m%d%H%M%S")

    filename = "%s/bug-report-%s.tar.bz2" % (bug_dir, date_string)
    subdir = "bug-report-%s" %  date_string

    bugball.append(string_iterator('inventory.xml',
                                   make_inventory(bugball_inventory, subdir)))

    now = time.time()

    tf = tarfile.open(filename, 'w:bz2')

    try:
        for f in bugball:
            tar_filename = os.path.join(subdir, truncated_name(f.name))
            ti = tarfile.TarInfo(tar_filename)

            if hasattr(f, 'size'):
                ti.size = f.size()
            else:
                ti.size = os.stat(f.name).st_size

            ti.mtime = now
            ti.type = tarfile.REGTYPE
            ti.uid = 0
            ti.gid = 0
            ti.uname = 'root'
            ti.gname = 'root'

            f.seek(0) # If we've added this file to a bug, it will have been
                      # read once already, so reset it.
            tf.addfile(ti, f)
    finally:
        tf.close()

    output ('Writing tarball %s successful.' % filename)
    if SILENT_MODE:
       print filename


def make_inventory(inventory, subdir):
    document = getDOMImplementation().createDocument(
        None, INVENTORY_XML_ROOT, None)
    map(lambda (f, e): inventory_entry(document, subdir, f, e),
        inventory.iteritems())
    return document.toprettyxml()

def inventory_entry(document, subdir, filename, capability):
    el = document.createElement(INVENTORY_XML_ELEMENT)
    try:
        el.setAttribute('md5sum', md5sum(filename))
    except:
        pass
    el.setAttribute('filename',
                    os.path.join(subdir, truncated_name(filename)))
    el.setAttribute('capability', capability)
    document.getElementsByTagName(INVENTORY_XML_ROOT)[0].appendChild(el)

def md5sum(f):
    return commands.getoutput("md5sum '" + f + "' | cut -d ' ' -f 1")


def truncated_name(f):
    if f.startswith(HOST_CRASHDUMPS_DIR):
        return f.replace(HOST_CRASHDUMPS_DIR + os.path.sep, '')
    else:
        return os.path.basename(f)


def update_capabilities():
    update_cap_size(CAP_HOST_CRASHDUMP_LOGS,
                    size_of_dir(HOST_CRASHDUMPS_DIR, HOST_CRASHDUMP_LOGS_RE))
    update_cap_size(CAP_HOST_CRASHDUMP_DUMPS,
                    size_of_dir(HOST_CRASHDUMPS_DIR, HOST_CRASHDUMP_LOGS_RE,
                                True))
    update_cap_size(CAP_XENSERVER_LOGS,  size_of_all(XENSERVER_LOGS))


def update_cap_size(cap, size):
    update_cap(cap, MIN_SIZE, size)
    update_cap(cap, MAX_SIZE, size)
    update_cap(cap, CHECKED, size > 0)


def update_cap(cap, k, v):
    global caps
    l = list(caps[cap])
    l[k] = v
    caps[cap] = tuple(l)


def size_of_dir(d, pattern = None, negate = False):
    if os.path.isdir(d):
        return size_of_all([os.path.join(d, fn) for fn in os.listdir(d)],
                           pattern, negate)
    else:
        return 0


def size_of_all(files, pattern = None, negate = False):
    return sum([size_of(f, pattern, negate) for f in files])


def matches(f, pattern, negate):
    if negate:
        return not matches(f, pattern, False)
    else:
        return pattern is None or pattern.match(f)


def size_of(f, pattern, negate):
    if os.path.isfile(f) and matches(f, pattern, negate):
        return os.stat(f)[6]
    else:
        return size_of_dir(f, pattern, negate)


def print_capabilities():
    document = getDOMImplementation().createDocument(
        "ns", CAP_XML_ROOT, None)
    map(lambda key: capability(document, key), caps.keys())
    print document.toprettyxml()

def capability(document, key):
    c = caps[key]
    el = document.createElement(CAP_XML_ELEMENT)
    el.setAttribute('key', c[KEY])
    el.setAttribute('pii', c[PII])
    el.setAttribute('min-size', str(c[MIN_SIZE]))
    el.setAttribute('max-size', str(c[MAX_SIZE]))
    el.setAttribute('min-time', str(c[MIN_TIME]))
    el.setAttribute('max-time', str(c[MAX_TIME]))
    el.setAttribute('content-type', c[MIME])
    el.setAttribute('default-checked', c[CHECKED] and 'yes' or 'no')
    document.getElementsByTagName(CAP_XML_ROOT)[0].appendChild(el)


def prettyDict(d):
    format = '%%-%ds: %%s' % max(map(len, [k for k, _ in d.items()]))
    return '\n'.join([format % i for i in d.items()]) + '\n'


class string_iterator(StringIO.StringIO):
    def __init__(self, name, val):
        StringIO.StringIO.__init__(self, val)
        self.name = name

    def size(self):
        return len(self.getvalue())


def yes(prompt):
    yn = raw_input(prompt)

    return len(yn) == 0 or yn.lower()[0] == 'y'


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print "\nInterrupted."
        sys.exit(1)
